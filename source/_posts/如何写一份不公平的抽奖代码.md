---
title: 如何写一份不公平的抽奖代码
date: 2021-03-31 14:26:33
tags: 
- 采样
- 洗牌
- golang
- 被动离职警告
categories: 算法
mathjax: true
---

「抽奖」是一种人民群众喜闻乐见的娱乐活动，其过程惊险刺激且回报丰厚，使得在商场开业、产品促销、公司年会等需要招揽人气 ~~但预算有限~~ 的情形下经常出现

从本质上说，抽奖是一种简单随机抽样算法，即如何从 n 个元素的数组中等概率无重复随机抽取 m 个样本（m<n）。本文从一份**不公平**的抽奖代码出发，讨论简单随机抽样算法中涉及到的一些有趣的问题

```go
// Wrong Code
func Sampling(slice []int, m int) []int {
	sort.Slice(slice, func(i, j int) bool { return rand.Float64() < 0.5 })
	return slice[:m]
}
```

上面的算法的思路很清晰：首先，随机打乱输入的数组的顺序；其次，乱序后取这个数组的前 m 个元素为样本（即中奖）。对输入的数组乱序的操作，也可称之为「洗牌」，我们着重看一下这个洗牌的实现：调用排序函数 `sort.Slice`对数组进行排序，在排序过程中元素两两比较时等概率地返回 `true` 和 `false`

乍一看好像没什么问题：如 a 和 b 相比较时，若返回 `false` 则最后 b 会在 a 前面，若返回 `true` 则最后 a 会在 b 前面，这两种情况是等概率的。另外，我们对所有的元素都是一视同仁的，想当然的话，洗牌后整个数组的元素会被洗的比较「散」，那么对于每个元素来说，中不中奖应该是很公平的一件事

可是，事实真的是这样吗？

<!-- more -->

# 是否真正公平

为了检验这个算法是不是真的公平，我写了个测试例子，数组大小从 `n=1` 开始到 `n=20` ，每种情况抽 100000 次，每次抽出一位幸运观众。我们统计一下各个位置的获奖概率是多少，如果各个位置的获奖概率相同，则我们可以说这个算法是公平的，否则肯定是不公平的

> 本文的代码均运行环境均是 ` go1.13.4 darwin/amd64`，这里为了方便后面扩展，定义了 `Sampler` 和 `Shuffler`  两个接口，分别代表抽样器和洗牌器

``` go
package main

import (
	"fmt"
	"math/rand"
	"sort"
)

func main() {
	sampler := ShufflerSampler{Shuffler: RandomSortShuffler{SortFunc: sort.Slice}}
	for i := 1; i <= 20; i++ {
		testSampling(sampler, generateSlice(i), 1, 1e5)
	}
}

type Sampler interface {
	fmt.Stringer
	Sampling(slice []int, m int) []int
}

type ShufflerSampler struct {
	Shuffler Shuffler
}

func (s ShufflerSampler) String() string {
	return fmt.Sprintf("ShufflerSampler with %s", s.Shuffler)
}

func (s ShufflerSampler) Sampling(slice []int, m int) []int {
	shuffled := s.Shuffler.Shuffle(slice)
	return shuffled[:m]
}

type Shuffler interface {
	fmt.Stringer
	Shuffle(slice []int) []int
}

type RandomSortShuffler struct {
	SortFunc func(slice interface{}, less func(i, j int) bool)
}

func (s RandomSortShuffler) String() string {
	return "RandomSortShuffler"
}

func (s RandomSortShuffler) Shuffle(slice []int) []int {
	cp := make([]int, len(slice))
	copy(cp, slice)
	s.SortFunc(cp, func(i, j int) bool { return rand.Float64() < 0.5 })
	return cp
}

func testSampling(sampler Sampler, slice []int, m int, times int) {
	n := len(slice)
	num2IdxMap := number2IndexMap(slice)

	result := make([]int, len(slice)) // [index]: count
	for i := 0; i < times; i++ {
		sampled := sampler.Sampling(slice, m)
		for _, num := range sampled {
			result[num2IdxMap[num]]++
		}
	}

	fmt.Printf("------- sampler: %s, n: %d, m:%d, times: %d -------\n", sampler, n, m, times)
	normalPosibility := float64(m) / float64(n)
	fmt.Printf("normal possibility:\n%.0f%%\n", normalPosibility*100)
	fmt.Printf("actual relative possibility:\n")
	for i := range result {
		posibility := float64(result[i]) / float64(times)
		difference := posibility - normalPosibility
		fmt.Printf("%+.0f%% ", difference*100)
	}
	fmt.Println()
}

func generateSlice(n int) []int {
	slice := make([]int, n)
	for i := range slice {
		slice[i] = 1000 * i
	}
	return slice
}

func number2IndexMap(slice []int) map[int]int {
	indexMap := make(map[int]int, len(slice))
	for idx, num := range slice {
		indexMap[num] = idx
	}
	return indexMap
}
```

上面的测试程序运行结果如下，我们打印了从 `n=1` 到 `n=20` 时数组每个位置被抽中的理论概率和实际值：如 `n=3` 时，每个位置被抽中的概率理论上都是 33%，但是数组的第 0 个位置被抽中的概率要比理论值高 4%（即 37%，下同），第 1 个位置要比理论值高 5%，第 2 个位置要比理论值低 8%

``` plain	
------- sampler: ShufflerSampler with RandomSortShuffler, n: 1, m:1, times: 100000 -------
normal possibility:
100%
actual relative possibility:
+0% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 2, m:1, times: 100000 -------
normal possibility:
50%
actual relative possibility:
-0% +0% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 3, m:1, times: 100000 -------
normal possibility:
33%
actual relative possibility:
+4% +5% -8% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 4, m:1, times: 100000 -------
normal possibility:
25%
actual relative possibility:
+8% +8% -3% -13% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 5, m:1, times: 100000 -------
normal possibility:
20%
actual relative possibility:
+11% +11% +0% -8% -14% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 6, m:1, times: 100000 -------
normal possibility:
17%
actual relative possibility:
+13% +13% +3% -5% -11% -14% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 7, m:1, times: 100000 -------
normal possibility:
14%
actual relative possibility:
+1% +15% +5% -3% -8% -11% +1% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 8, m:1, times: 100000 -------
normal possibility:
12%
actual relative possibility:
+3% +2% +7% -1% -7% -9% +3% +2% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 9, m:1, times: 100000 -------
normal possibility:
11%
actual relative possibility:
+4% +4% -1% -0% -5% -8% +4% +4% -1% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 10, m:1, times: 100000 -------
normal possibility:
10%
actual relative possibility:
+5% +5% -0% -4% -4% -7% +5% +5% -0% -4% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 11, m:1, times: 100000 -------
normal possibility:
9%
actual relative possibility:
+6% +6% +1% -4% -6% -6% +6% +6% +1% -3% -6% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 12, m:1, times: 100000 -------
normal possibility:
8%
actual relative possibility:
+7% +6% +1% -3% -5% -7% +7% +7% +2% -3% -5% -7% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 13, m:1, times: 100000 -------
normal possibility:
8%
actual relative possibility:
-4% +14% +4% -1% -3% -1% -3% +1% -1% -1% -1% +0% -5% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 14, m:1, times: 100000 -------
normal possibility:
7%
actual relative possibility:
-4% +12% +5% -1% -3% -2% +3% -4% -0% -1% -1% -0% +1% -5% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 15, m:1, times: 100000 -------
normal possibility:
7%
actual relative possibility:
-4% +11% +4% -1% -3% -3% +3% -4% +0% +0% -0% -1% -0% +1% -5% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 16, m:1, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-4% +9% +4% -1% -3% -3% +3% +2% -4% +0% +0% -0% -0% +0% +1% -5% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 17, m:1, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-3% +9% +3% -1% -3% -3% +3% +2% -3% +0% +0% +0% -0% -0% -0% +1% -4% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 18, m:1, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-3% +8% +3% -1% -3% -4% +3% +3% +1% -3% +0% +0% +0% -0% -0% -0% +1% -4% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 19, m:1, times: 100000 -------
normal possibility:
5%
actual relative possibility:
-3% +8% +3% -1% -3% -3% +3% +2% +1% -3% +0% +1% +0% -0% -1% -0% -0% +1% -4% 
------- sampler: ShufflerSampler with RandomSortShuffler, n: 20, m:1, times: 100000 -------
normal possibility:
5%
actual relative possibility:
-3% +8% +2% -1% -2% -3% +3% +2% +1% +0% -3% +1% +0% -0% -1% -0% -0% -0% +0% -4% 
```

我们可以大致总结出如下较明显的现象：

1. `n<3` 时各个位置被抽中的概率是相等的，从 `n=3` 开始，各个位置被抽中的概率有偏差，有的位置比理论概率高，有的位置比理论概率低；
2. `3<=n<=12` 时，第一个元素被抽中的概率要高于理论概率；`n>12` 后，第一个元素被抽中的概率要低于理论概率；

> 调整 `m` 的值重新测试，可以得到比较相似的结论

很容易看出，上面的算法肯定是**不公平**的，如果知道某个业务用了这种抽奖算法，那么可以在元素顺序上做文章以提高自己的中奖概率；相反，如果在某种业务中写出了这种抽奖算法，那基本上就凉凉了...

# 洗牌算法的随机性

我们来倒推上述结果的原因，上述算法可以概括为「洗牌后取前 `m` 个元素作为样本」，故不公平的原因一定是上面的洗牌算法并不随机，这一小节我们来详细讨论

## 基于排序的算法

上面洗牌算法是基于排序的，在排序时元素两两比较的返回的是随机结果，之前我们「想当然」地觉得这个应该洗牌没什么问题，我们先验证下看是否真的如此：

> 为了节省篇幅，这里的代码除了 main 函数外均为增量代码，下同

```go

func main() {
	shuffler := RandomSortShuffler{SortFunc: sort.Slice}
	for i := 1; i <= 20; i++ {
		testShuffle(shuffler, generateSlice(i), 1e5)
	}
}

func testShuffle(shuffler Shuffler, slice []int, times int) {
	n := len(slice)
	num2IdxMap := number2IndexMap(slice)

	result := make([][]int, n) // [index after shuffle][original index]:count
	for i := range result {
		result[i] = make([]int, n)
	}

	for i := 0; i < times; i++ {
		shuffled := shuffler.Shuffle(slice)
		for newIdx, num := range shuffled {
			result[newIdx][num2IdxMap[num]]++
		}
	}

	fmt.Printf("------- shuffler: %s, n: %d, times: %d -------\n", shuffler, n, times)
	normalPosibility := float64(1) / float64(n)
	fmt.Printf("normal possibility:\n%.0f%%\n", normalPosibility*100)
	fmt.Printf("actual relative possibility:\n")
	for i := range result {
		for j := range result[i] {
			posibility := float64(result[i][j]) / float64(times)
			difference := posibility - normalPosibility
			fmt.Printf("%+.0f%% ", difference*100)
		}
		fmt.Println()
	}
}
```

上面的测试程序运行结果如下，我们打印了从 `n=1` 到 `n=20` 时，数组每个元素在洗牌后出现在的各个位置的理论概率和实际值，其中实际值的表示是 $n\times n$ 的矩阵 $A$，其中 $a_{ij}$ 表示洗牌前数组 j 位置上的元素经过洗牌移动到 i 位置上的概率。如 `n=3` 时，数组每个元素在洗牌后在各个位置的概率理论上都应该是 33%，但是最后一个位置的元素在经过洗牌后仍在最后一个位置的概率比理论值高了 17%（即 50%）

```plain
------- shuffler: RandomSortShuffler, n: 1, times: 100000 -------
normal possibility:
100%
actual relative possibility:
+0% 
------- shuffler: RandomSortShuffler, n: 2, times: 100000 -------
normal possibility:
50%
actual relative possibility:
-0% +0% 
+0% -0% 
------- shuffler: RandomSortShuffler, n: 3, times: 100000 -------
normal possibility:
33%
actual relative possibility:
+4% +5% -8% 
+4% +4% -8% 
-8% -9% +17% 
------- shuffler: RandomSortShuffler, n: 4, times: 100000 -------
normal possibility:
25%
actual relative possibility:
+8% +8% -3% -13% 
+8% +8% -3% -13% 
-3% -3% +6% +0% 
-13% -13% +0% +25% 
------- shuffler: RandomSortShuffler, n: 5, times: 100000 -------
normal possibility:
20%
actual relative possibility:
+11% +11% +0% -8% -14% 
+11% +11% +1% -8% -14% 
+0% +0% +6% +0% -8% 
-8% -8% +0% +11% +5% 
-14% -14% -8% +5% +30% 
------- shuffler: RandomSortShuffler, n: 6, times: 100000 -------
normal possibility:
17%
actual relative possibility:
+13% +13% +3% -5% -11% -14% 
+13% +13% +3% -5% -11% -13% 
+3% +4% +7% +2% -5% -10% 
-5% -5% +2% +9% +4% -4% 
-11% -11% -5% +4% +15% +8% 
-14% -14% -10% -4% +9% +33% 
------- shuffler: RandomSortShuffler, n: 7, times: 100000 -------
normal possibility:
14%
actual relative possibility:
+1% +15% +5% -3% -8% -11% +1% 
+1% +15% +5% -3% -8% -11% +1% 
-3% +5% +9% +4% -4% -8% -3% 
-5% -3% +3% +10% +4% -3% -6% 
-5% -8% -3% +4% +12% +6% -5% 
-0% -11% -8% -3% +6% +17% -0% 
+12% -13% -11% -8% -2% +11% +11% 
------- shuffler: RandomSortShuffler, n: 8, times: 100000 -------
normal possibility:
12%
actual relative possibility:
+3% +2% +7% -1% -7% -9% +3% +2% 
+3% +2% +7% -2% -7% -9% +3% +3% 
-1% -2% +10% +5% -2% -7% -1% -2% 
-4% -5% +5% +11% +5% -2% -4% -5% 
-4% -6% -2% +5% +11% +6% -4% -6% 
-1% -5% -7% -2% +6% +13% -1% -5% 
+4% +1% -10% -7% -1% +8% +4% +1% 
+0% +13% -11% -9% -6% -0% +0% +13% 
------- shuffler: RandomSortShuffler, n: 9, times: 100000 -------
normal possibility:
11%
actual relative possibility:
+4% +4% -1% -0% -5% -8% +4% +4% -1% 
+4% +4% -1% -0% -5% -8% +4% +4% -1% 
+0% -1% +1% +6% -1% -5% -0% -1% +1% 
-3% -4% -2% +12% +6% -1% -3% -4% -2% 
-3% -5% -4% +6% +12% +6% -3% -5% -4% 
-0% -4% -5% -0% +7% +13% -0% -4% -5% 
+3% -0% -3% -5% -0% +8% +3% -0% -3% 
-1% +5% +2% -8% -5% +0% -0% +5% +2% 
-5% +1% +14% -10% -8% -5% -5% +2% +14% 
------- shuffler: RandomSortShuffler, n: 10, times: 100000 -------
normal possibility:
10%
actual relative possibility:
+5% +5% -0% -4% -4% -7% +5% +5% -0% -4% 
+5% +5% -0% -4% -4% -7% +5% +5% -0% -4% 
+1% +1% +2% -1% +0% -4% +1% +1% +2% -1% 
-2% -3% -1% +2% +7% +0% -2% -3% -1% +2% 
-2% -4% -3% -1% +12% +7% -2% -4% -3% -1% 
+0% -3% -4% -3% +7% +13% +0% -3% -4% -3% 
+3% +0% -3% -4% +1% +8% +3% +0% -3% -4% 
-0% +3% +1% -2% -4% +1% -0% +3% +1% -2% 
-4% +0% +6% +3% -7% -4% -4% +0% +6% +4% 
-7% -4% +2% +16% -8% -7% -7% -4% +3% +15% 
------- shuffler: RandomSortShuffler, n: 11, times: 100000 -------
normal possibility:
9%
actual relative possibility:
+6% +6% +1% -4% -6% -6% +6% +6% +1% -3% -6% 
+6% +6% +1% -3% -6% -6% +6% +6% +1% -3% -6% 
+2% +1% +3% -1% -4% -3% +2% +1% +3% -0% -4% 
-1% -2% +0% +2% -0% +1% -1% -2% +0% +2% -1% 
-1% -3% -2% +0% +2% +8% -1% -3% -3% +0% +2% 
+1% -2% -3% -2% +0% +13% +1% -2% -3% -2% +0% 
+3% +0% -2% -3% -2% +8% +3% +1% -2% -3% -2% 
+0% +3% +1% -2% -3% +1% +0% +3% +1% -2% -3% 
-3% +0% +4% +2% -1% -3% -3% +0% +4% +2% -1% 
-6% -3% +1% +7% +4% -6% -6% -3% +1% +7% +4% 
-7% -6% -3% +4% +16% -7% -7% -6% -3% +4% +17% 
------- shuffler: RandomSortShuffler, n: 12, times: 100000 -------
normal possibility:
8%
actual relative possibility:
+7% +6% +1% -3% -5% -7% +7% +7% +2% -3% -5% -7% 
+7% +6% +2% -3% -5% -7% +7% +6% +2% -3% -5% -7% 
+3% +2% +3% +0% -3% -5% +3% +2% +3% +0% -3% -5% 
+0% -1% +1% +3% +0% -3% +0% -1% +1% +3% +0% -3% 
-0% -3% -2% +1% +3% +0% -0% -2% -2% +1% +3% +0% 
+2% -2% -3% -2% +1% +3% +2% -2% -3% -2% +1% +3% 
+4% +1% -2% -3% -1% +1% +4% +1% -1% -3% -2% +1% 
+1% +4% +1% -1% -2% -2% +1% +4% +1% -1% -2% -2% 
-3% +1% +4% +2% -1% -2% -3% +1% +4% +2% -1% -2% 
-5% -3% +1% +5% +2% -1% -5% -3% +1% +5% +3% -1% 
-7% -5% -3% +2% +8% +5% -7% -5% -3% +2% +8% +5% 
-8% -7% -5% -2% +5% +17% -8% -7% -5% -2% +4% +17% 
------- shuffler: RandomSortShuffler, n: 13, times: 100000 -------
normal possibility:
8%
actual relative possibility:
-4% +14% +4% -1% -3% -1% -3% +1% -1% -1% -1% +0% -5% 
-4% +14% +4% -1% -3% -1% -3% +1% -1% -1% -1% +1% -5% 
-4% +7% +8% +2% -1% -2% -4% -0% -1% -0% -0% +0% -5% 
-3% +0% +3% +7% +2% -2% -3% -1% -0% +0% +0% -0% -5% 
-1% -4% -1% +2% +8% +0% -1% -1% -0% -0% +0% -1% -3% 
+2% -5% -4% -2% +2% +9% +2% +0% -0% -1% -2% -1% -1% 
+7% -5% -4% -3% -1% +1% +7% +2% +0% -2% -3% -3% +4% 
+4% -4% -3% -2% -1% -1% +4% +8% +1% -1% -3% -3% +2% 
-1% -4% -2% -0% +0% +0% -2% +1% +10% +3% -1% -3% -2% 
-2% -4% -1% -0% +0% +0% -2% +0% +2% +7% +2% -1% -1% 
-1% -3% -1% +0% -0% -1% -1% -2% -1% +2% +6% +2% +0% 
+1% -3% -1% -1% -1% -1% +1% -4% -4% -1% +2% +6% +5% 
+6% -4% -3% -2% -3% -2% +6% -6% -5% -4% -2% +3% +15% 
------- shuffler: RandomSortShuffler, n: 14, times: 100000 -------
normal possibility:
7%
actual relative possibility:
-4% +12% +5% -1% -3% -2% +3% -4% -0% -1% -1% -0% +1% -5% 
-4% +12% +4% -1% -3% -2% +3% -4% -0% -1% -1% -0% +1% -5% 
-4% +5% +7% +3% -1% -2% +1% -4% -0% -0% -0% +0% +1% -5% 
-4% +0% +4% +7% +2% -1% -1% -4% -0% +0% +0% +0% +0% -5% 
-2% -3% -1% +3% +8% +2% -2% -2% -0% +0% +1% +0% -1% -4% 
+1% -4% -3% -1% +2% +9% -2% +1% +1% -0% -1% -0% -1% -1% 
+4% -3% -4% -3% -1% +2% +4% +4% +2% -0% -2% -2% -1% +2% 
+6% -1% -4% -3% -2% -1% -1% +6% +2% -0% -2% -3% -2% +4% 
+3% -4% -2% -2% -1% -0% -1% +3% +7% +1% -1% -3% -3% +2% 
-2% -4% -2% -0% +0% +0% -0% -2% +2% +9% +3% -1% -3% -1% 
-2% -3% -1% +0% +0% +0% -0% -2% -0% +2% +6% +2% -1% -1% 
-1% -3% -1% +0% +0% -0% -1% -1% -2% -1% +2% +5% +1% +0% 
+1% -2% -0% -0% -1% -1% -1% +1% -4% -4% -1% +2% +6% +5% 
+6% -4% -2% -2% -2% -2% -2% +6% -6% -5% -4% -1% +3% +14% 
------- shuffler: RandomSortShuffler, n: 15, times: 100000 -------
normal possibility:
7%
actual relative possibility:
-4% +11% +4% -1% -3% -3% +3% -4% +0% +0% -0% -1% -0% +1% -5% 
-3% +11% +4% -0% -3% -3% +3% -4% +0% +0% -1% -1% -0% +1% -5% 
-4% +5% +6% +3% -1% -2% +1% -4% -0% -0% -0% +0% +0% +1% -5% 
-4% +0% +3% +7% +3% -1% -1% -4% -0% -0% +0% +1% +1% +1% -5% 
-3% -2% -1% +3% +7% +2% -2% -3% -0% +0% +1% +1% +0% -1% -4% 
-0% -3% -3% -1% +3% +8% -2% -0% +0% +0% +0% +0% -0% -2% -2% 
+3% -1% -3% -3% -1% +3% +3% +3% +1% +0% -1% -1% -1% -2% +0% 
+5% +2% -2% -3% -2% -1% -1% +5% -1% +0% -2% -2% -2% -0% +3% 
+4% -3% -0% -2% -2% -1% -1% +4% +3% +2% -0% -2% -3% -2% +4% 
+3% -4% -3% -1% -1% -1% -0% +3% -1% +7% +2% -1% -3% -3% +2% 
-1% -4% -2% -0% +0% +0% +0% -1% -1% +2% +8% +3% -1% -3% -1% 
-1% -3% -1% +0% +0% +0% -0% -1% -1% -0% +2% +6% +2% -2% -1% 
-1% -3% -0% +0% +0% +0% -0% -1% -2% -3% -1% +2% +5% +1% +0% 
+1% -2% -0% -0% -0% -1% -1% +1% -1% -4% -3% -1% +2% +5% +5% 
+5% -3% -2% -2% -2% -2% -2% +5% +2% -5% -5% -4% -1% +3% +13% 
------- shuffler: RandomSortShuffler, n: 16, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-4% +9% +4% -1% -3% -3% +3% +2% -4% +0% +0% -0% -0% +0% +1% -5% 
-4% +9% +4% -0% -3% -3% +3% +2% -4% +0% +0% -0% -1% -0% +1% -5% 
-4% +4% +6% +3% -0% -2% +1% -0% -4% -0% -0% -0% +0% +1% +1% -5% 
-4% +1% +3% +6% +3% -0% -1% -1% -4% -0% +0% +0% +1% +1% +1% -5% 
-3% -2% -1% +3% +7% +3% -2% -1% -3% +0% +1% +1% +1% +0% -0% -4% 
-1% -2% -2% -1% +3% +8% -1% -0% -1% +0% +0% +1% +0% -0% -1% -3% 
+1% -0% -3% -3% -1% +3% +2% +1% +1% +0% +0% -0% -0% -1% -2% -1% 
+3% +3% -1% -3% -2% -0% -1% +3% +3% -0% -1% -2% -1% -1% -1% +1% 
+5% -1% +1% -2% -2% -2% -1% -0% +5% -1% -0% -2% -2% -1% +0% +3% 
+4% -4% -2% +0% -2% -1% -1% -1% +4% +3% +2% -0% -2% -3% -1% +4% 
+2% -4% -3% -1% -0% -0% -0% -0% +2% -1% +6% +2% -1% -2% -3% +2% 
-1% -4% -2% -0% +0% +1% +0% -0% -1% -1% +3% +7% +3% -1% -2% -1% 
-2% -3% -1% +0% +1% +0% +0% -0% -1% -1% -0% +2% +5% +2% -1% -1% 
-1% -2% -0% +0% +0% +0% -0% -0% -1% -2% -3% -1% +2% +4% +1% +1% 
+1% -2% -0% -0% -0% -1% -1% -1% +2% -0% -4% -3% -1% +2% +5% +5% 
+5% -3% -2% -1% -2% -2% -2% -2% +5% +3% -5% -5% -3% -1% +2% +12% 
------- shuffler: RandomSortShuffler, n: 17, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-3% +9% +3% -1% -3% -3% +3% +2% -3% +0% +0% +0% -0% -0% -0% +1% -4% 
-3% +9% +3% -1% -3% -3% +3% +2% -3% +0% +0% +0% -0% -0% -0% +1% -4% 
-3% +4% +5% +2% -1% -2% +1% +0% -3% -0% -0% -0% -0% +0% +1% +1% -4% 
-4% +0% +3% +5% +3% -0% -1% -1% -4% -0% -0% +0% +1% +1% +1% +1% -4% 
-3% -1% -0% +3% +6% +3% -1% -2% -3% +0% +0% +0% +1% +1% +1% -0% -4% 
-2% -1% -2% -1% +3% +8% -0% -1% -2% +0% +1% +1% +1% +0% -0% -1% -3% 
+0% +1% -2% -2% -0% +4% +2% +2% +0% +0% +0% +0% +0% -0% -1% -2% -2% 
+2% +4% -1% -2% -2% -0% -0% +3% +2% -0% -1% -1% -1% -0% -1% -1% -0% 
+5% -0% +3% -1% -2% -2% -2% -0% +5% -0% -1% -1% -2% -1% +0% -0% +2% 
+4% -2% -1% +1% -1% -2% -2% -1% +4% +3% -1% -0% -2% -2% -1% +1% +3% 
+3% -4% -2% -1% +0% -1% -1% -1% +3% -0% +2% +3% -0% -2% -2% -1% +4% 
+2% -4% -2% -1% -0% +0% -0% -0% +2% -1% -0% +6% +2% -1% -2% -2% +2% 
-1% -3% -2% -0% +0% +1% +1% +0% -1% -1% -1% +3% +6% +2% -1% -2% -0% 
-1% -3% -1% +0% +1% +1% +0% +0% -1% -1% -2% -0% +2% +5% +1% -1% -0% 
-1% -2% -1% +0% +1% +0% -0% -0% -1% -1% -2% -2% -1% +2% +4% +1% +1% 
+1% -2% -0% +0% -0% -0% -1% -1% +1% +1% -0% -4% -3% -1% +2% +4% +4% 
+4% -3% -2% -1% -1% -1% -2% -2% +4% -0% +4% -5% -4% -3% -1% +2% +11% 
------- shuffler: RandomSortShuffler, n: 18, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-3% +8% +3% -1% -3% -4% +3% +3% +1% -3% +0% +0% +0% -0% -0% -0% +1% -4% 
-3% +8% +3% -1% -3% -3% +3% +3% +1% -3% +0% +0% +0% -0% -0% -0% +1% -4% 
-3% +4% +4% +2% -0% -2% +1% +0% +1% -3% +0% -0% +0% +0% +0% +1% +1% -4% 
-3% +0% +2% +5% +3% -0% -1% -1% -0% -3% -0% +0% +0% +1% +1% +1% +0% -4% 
-3% -1% -0% +2% +6% +3% -1% -2% -1% -3% +0% +0% +1% +1% +1% +1% -0% -4% 
-2% -1% -2% -0% +3% +7% +0% -1% -0% -2% +1% +1% +1% +1% +0% -0% -1% -3% 
-1% +1% -2% -2% -0% +4% +2% +1% +1% -1% +1% +1% +0% +0% -1% -1% -1% -2% 
+1% +4% -0% -2% -2% -0% +0% +2% +1% +1% -0% -1% -1% -0% -1% -1% -1% -1% 
+3% +0% +3% -1% -2% -2% -2% +0% +3% +3% -1% -2% -1% -1% -0% -0% -1% +0% 
+4% -2% +0% +2% -1% -2% -2% -1% +0% +5% -0% -2% -1% -2% -1% +0% -0% +2% 
+4% -3% -2% -1% +1% -1% -2% -1% -1% +4% +2% -1% +0% -2% -2% -1% +1% +3% 
+3% -3% -2% -2% -1% +0% -1% -1% -1% +3% -0% +2% +3% +0% -2% -2% -1% +4% 
+1% -4% -2% -1% -0% -0% +0% +0% -0% +1% -1% -0% +6% +3% -1% -2% -2% +2% 
-1% -3% -2% -0% +0% +1% +0% +0% -0% -1% -1% -1% +3% +6% +2% -1% -2% -0% 
-1% -3% -1% +0% +1% +1% +0% +0% +0% -1% -1% -2% -0% +3% +4% +1% -1% -0% 
-0% -2% -0% +0% +1% +0% +0% -0% -0% -0% -0% -1% -2% -1% +2% +4% +1% +1% 
+1% -2% -0% -0% +0% -0% -1% -1% -1% +1% +1% +0% -4% -3% -1% +2% +4% +4% 
+4% -3% -2% -1% -1% -1% -1% -2% -2% +4% +0% +5% -5% -4% -3% -1% +2% +11% 
------- shuffler: RandomSortShuffler, n: 19, times: 100000 -------
normal possibility:
5%
actual relative possibility:
-3% +8% +3% -1% -3% -3% +3% +2% +1% -3% +0% +1% +0% -0% -1% -0% -0% +1% -4% 
-3% +8% +3% -1% -2% -3% +3% +2% +1% -3% +0% +0% +0% -0% -0% -0% +0% +0% -4% 
-3% +4% +4% +2% -1% -2% +1% +0% +1% -3% -0% +0% +0% -0% +0% +0% +0% +1% -4% 
-3% +0% +2% +4% +2% -0% -1% -1% -0% -3% -0% -0% +0% +0% +0% +1% +1% +0% -4% 
-3% -1% -0% +2% +5% +3% -1% -2% -1% -3% +0% +0% +0% +1% +1% +1% +1% -0% -4% 
-2% -1% -2% -0% +3% +6% +0% -1% -1% -2% +1% +1% +1% +1% +1% +0% -0% -1% -3% 
-1% +2% -2% -2% -0% +3% +2% +1% +1% -1% +1% +1% +1% +0% -0% -0% -1% -1% -3% 
+0% +5% +0% -2% -2% -0% +0% +3% +1% +0% -0% -0% -0% -0% -0% -1% -1% -1% -1% 
+2% +1% +3% -0% -2% -2% -2% +0% +3% +2% -1% -1% -1% -1% -0% -0% -1% -1% -0% 
+4% -2% +0% +2% -1% -2% -2% -1% +0% +4% +0% -1% -2% -1% -1% +0% +0% -1% +2% 
+3% -2% -1% -0% +1% -1% -2% -1% -1% +4% +2% -0% -2% -1% -2% -1% +1% -0% +2% 
+3% -3% -1% -1% -0% +0% -1% -1% -1% +3% -0% +2% -1% +1% -1% -2% -0% +1% +3% 
+2% -3% -2% -1% -1% -0% -0% -1% -1% +2% -1% -0% +2% +3% -0% -2% -2% -0% +3% 
+1% -3% -2% -1% -0% +0% +0% +0% -0% +1% -1% -1% -0% +6% +3% -1% -2% -2% +2% 
-0% -3% -1% -0% +0% +1% +1% +0% +0% -1% -1% -1% -1% +3% +5% +2% -1% -2% +0% 
-1% -3% -1% +0% +0% +1% +1% +0% -0% -1% -0% -1% -2% +0% +2% +4% +1% -1% -0% 
-0% -2% -1% +0% +0% +0% +0% -0% -1% -0% +0% -0% -1% -2% -1% +2% +4% +1% +1% 
+1% -2% -0% -0% -0% -0% -0% -1% -1% +1% -0% +1% +1% -4% -3% -1% +1% +4% +4% 
+4% -3% -2% -1% -1% -1% -1% -1% -2% +4% -1% +1% +5% -4% -4% -3% -1% +2% +10% 
------- shuffler: RandomSortShuffler, n: 20, times: 100000 -------
normal possibility:
5%
actual relative possibility:
-3% +8% +2% -1% -2% -3% +3% +2% +1% +0% -3% +1% +0% -0% -1% -0% -0% -0% +0% -4% 
-3% +8% +2% -1% -2% -3% +2% +2% +1% +0% -3% +1% +0% -1% -1% -0% -0% -0% +1% -4% 
-3% +4% +4% +2% -1% -2% +0% +0% +1% +0% -3% +0% +0% -0% -0% +0% +0% +0% +1% -4% 
-3% +1% +2% +4% +2% -0% -1% -1% -0% +0% -3% -0% +0% +0% +0% +1% +1% +1% +0% -4% 
-3% -1% -0% +2% +5% +3% -1% -2% -1% +0% -3% -0% +0% +1% +1% +1% +1% +0% -0% -4% 
-2% -0% -2% -0% +2% +6% +0% -1% -1% -0% -2% +1% +1% +1% +0% +1% +0% -0% -1% -3% 
-2% +2% -1% -2% -0% +3% +2% +1% +0% +0% -2% +1% +1% +1% +0% -0% -0% -1% -1% -3% 
-0% +5% +0% -2% -2% +0% +0% +2% +1% +0% -1% -0% +0% -0% -0% -1% -1% -1% -0% -2% 
+1% +1% +3% -0% -2% -1% -2% +0% +3% +1% +1% -1% -1% -1% -0% -0% -1% -1% -0% -1% 
+3% -2% +0% +2% -1% -2% -2% -1% +1% +3% +3% -1% -1% -2% -1% +0% -0% -0% -1% +0% 
+4% -2% -1% +0% +2% -1% -2% -1% -1% +1% +4% -0% -1% -2% -1% -0% +1% -0% -1% +2% 
+3% -2% -1% -1% -0% +1% -1% -1% -1% -0% +3% +3% -0% -1% -1% -1% -0% +1% -0% +2% 
+3% -2% -1% -1% -1% -1% -0% -1% -1% -1% +3% +0% +2% +0% +1% -1% -1% -0% +1% +3% 
+2% -3% -2% -1% -1% -1% -0% +0% -0% -1% +2% -1% -0% +1% +3% -0% -2% -2% -1% +3% 
+1% -3% -2% -1% -0% +0% +0% +0% -0% -0% +1% -1% -1% +0% +6% +2% -1% -2% -2% +2% 
-0% -3% -1% -0% +0% +1% +1% +0% +0% +0% -0% -1% -1% -1% +3% +5% +2% -1% -2% +0% 
-1% -3% -1% -0% +1% +1% +1% +0% -0% -0% -1% -0% -1% -2% -0% +2% +4% +1% -1% +0% 
-0% -2% -1% +0% +0% +0% +0% -0% -1% -1% -0% +1% -0% -1% -2% -1% +2% +3% +1% +1% 
+1% -2% -1% -0% +0% +0% -0% -1% -1% -1% +1% -0% +2% +1% -3% -3% -1% +1% +4% +3% 
+4% -3% -2% -1% -1% -1% -1% -1% -1% -2% +4% -1% +1% +6% -4% -4% -3% -1% +2% +10% 
```

很明显，确实是洗牌算法有问题，我们的「想当然」是不对的。根本原因在于我们依赖了**排序**，而两个元素的排序和多个元素的排序其实有细微差别，这个差别在于： `n>=3` 的情况下，**两个元素并非有相同的比较机会**。两个元素随机比较在 `n=2` 时确实是没问题的，但是推广到 `n>=3` 的情况就会失败

我们看一下这个排序函数的源码，具体在 `sort/slice.go` 里，代码如下：

```go
// Slice sorts the provided slice given the provided less function.
//
// The sort is not guaranteed to be stable. For a stable sort, use
// SliceStable.
//
// The function panics if the provided interface is not a slice.
func Slice(slice interface{}, less func(i, j int) bool) {
	rv := reflectValueOf(slice)
	swap := reflectSwapper(slice)
	length := rv.Len()
	quickSort_func(lessSwap{less, swap}, 0, length, maxDepth(length))
}
```

其主要调用了 `sort/zfuncversion.go` 中的 `quickSort_func` 函数，代码如下

```go
// Auto-generated variant of sort.go:quickSort
func quickSort_func(data lessSwap, a, b, maxDepth int) {
	for b-a > 12 {
		if maxDepth == 0 {
			heapSort_func(data, a, b)
			return
		}
		maxDepth--
		mlo, mhi := doPivot_func(data, a, b)
		if mlo-a < b-mhi {
			quickSort_func(data, a, mlo, maxDepth)
			a = mhi
		} else {
			quickSort_func(data, mhi, b, maxDepth)
			b = mlo
		}
	}
	if b-a > 1 {
		for i := a + 6; i < b; i++ {
			if data.Less(i, i-6) {
				data.Swap(i, i-6)
			}
		}
		insertionSort_func(data, a, b)
	}
}
```

可以看出，在数组长度 `n>12` 时会使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)，否则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)，这两个基础排序算法大家应该比较熟悉了，这里不再展开，我们直接在 `n=3` 情况下结合插入排序算法来解释为什么元素间的比较机会有区别

假设我们的原数组是 `[a,b,c]`，下面列举了插入排序每一步时的比较情况和中间结果的合集

<table>
   <tr>
      <td>原数组</td>
      <td>i=1, j=1</td>
      <td>i=2, j=2</td>
      <td>i=2, j =1</td>
      <td>最终结果</td>
      <td>实际概率</td>
   </tr>
   <tr>
      <td rowspan=6>[a,b,c]</td>
      <td rowspan=3>compare(b,a) -> [a,b,c]</td>
      <td>compare(c,b) -> [a,b,c]</td>
      <td>/</td>
      <td>[a, b, c]</td>
      <td>0.25</td>
   </tr>
   <tr>
      <td>compare(c,b) -> [a,c,b]</td>
      <td>compare(c,a) -> [a,c,b] </td>
      <td>[a, c, b]</td>
      <td>0.125</td>
   </tr>
   <tr>
      <td>compare(c,b) -> [a,c,b]</td>
      <td>compare(c,a) -> [c,a,b] </td>
      <td>[c, a, b]</td>
      <td>0.125</td>
   </tr>
   <tr>
      <td rowspan=3>compare(b,a) -> [b,a,c]</td>
      <td>compare(c,a) -> [b,a,c]</td>
      <td>/</td>
      <td>[b, a, c]</td>
      <td>0.25</td>
   </tr>
   <tr>
      <td>compare(c,a) -> [b,c,a]</td>
      <td>compare(c,b) -> [b,c,a]</td>
      <td>[b, c, a]</td>
      <td>0.125</td>
   </tr>
   <tr>
      <td>compare(c,a) -> [b,c,a]</td>
      <td>compare(c,b) -> [c,b,a]</td>
      <td>[c, b, a]</td>
      <td>0.125</td>
   </tr>
</table>

以最终结果 `[c,b,a]` 的路径为例，我们来看一下其 0.125 的概率是如何计算出的：`i=1` 时，发生第一次比较，比较的是 c 和 b，有 50% 的概率进行交换并得到结果 `[b,a,c]`； `i=2` 时，首先在 `j=2` 时发生第二次比较，比较的是 c 和 a，有 50% 的概率进行交换并得到结果 `[b,c,a]`，然后在 `j=1` 时发生第三次比较，比较的是 c 和 b，有 50% 的概率进行交换并的得到最终结果 `[c,b,a]`。可以看出，这个例子里比较一共发生了 3 次，整个路径的概率为 $0.5^3 = 0.125$。再以最终结果 `[a,b,c]` 的路径为例，由于在 `i=2,j=2` 比较完后直接返回了，所以整个过程只发生了 2 次比较，故概率为 $0.5^2 = 0.25$

我们统计下最终结果中 c 在最后一个位置的概率，也就是 `[b,a,c]` 和 `[a,b,c]`  情况的概率之和 $0.25+0.25 = 0.5$，其和理论值 $0.33$ 的偏差为 $0.17$，这个结果和上面的测试结果矩阵 $a_{33}$ 完全一致，说明我们的分析是正确的

在所有的可能情况中，我们统计下各个元素相互比较的次数

| 比较双方 | 比较次数 |
| -------- | -------- |
| (a,b)    | 6        |
| (b,c)    | 5        |
| (c,a)    | 5        |

可以看出，不同元素间的比较机会确实是不等的，导致了**数组的全排列中的每一种情况出现的概率是不等的**，最终导致了洗牌后各个元素在新数组位置中出现的概率是不等的，所以这种基于随机排序的洗牌算法是错误的

> 我们之前观察到的 `n=12` 前后第一个元素被选中的概率会**突变**，这个现象我们也能够从代码里找到端倪，其根本原因就是 `n=12` 时候 `sort.Slice` 排序算法从插入排序切换到了快速排序，导致了元素间比较次数的差别。相似的，如果有兴趣可以将排序函数换为 `sort.SliceStable` 试试，测试结果又会有不同

## Fisher-Yates 算法

关于洗牌其实有比较正统的算法，如 [Fisher-Yates](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) 算法，该算法能够保证数组每个元素在洗牌后都能等概率的到任意的一个位置。算法本身不是太复杂，对于长度为 `n` 的数组，可以概括为以下两个步骤：

1. 从 `k = n-1` 开始，在 `[0, k]` 区间内随机取一个位置和 `k` 位置上的元素交换
2. `k` 依次递减，重复上述过程，直到 `k=0` 结束

`rand` 包里已经有该算法的实现，直接调用 `rand.Shuffle` 函数即可完成一次随机洗牌，源码在 `math/rand/rand.go` 里，摘录如下

```go
// Shuffle pseudo-randomizes the order of elements.
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
func (r *Rand) Shuffle(n int, swap func(i, j int)) {
	if n < 0 {
		panic("invalid argument to Shuffle")
	}

	// Fisher-Yates shuffle: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
	// Shuffle really ought not be called with n that doesn't fit in 32 bits.
	// Not only will it take a very long time, but with 2³¹! possible permutations,
	// there's no way that any PRNG can have a big enough internal state to
	// generate even a minuscule percentage of the possible permutations.
	// Nevertheless, the right API signature accepts an int n, so handle it as best we can.
	i := n - 1
	for ; i > 1<<31-1-1; i-- {
		j := int(r.Int63n(int64(i + 1)))
		swap(i, j)
	}
	for ; i > 0; i-- {
		j := int(r.int31n(int32(i + 1)))
		swap(i, j)
	}
}
```

我们先看一下这个洗牌算法的效果，测试代码如下：

```go
func main() {
	shuffler := FisherYatesShuffler{}
	for i := 1; i <= 20; i++ {
		testShuffle(shuffler, generateSlice(i), 1e5)
	}
}

type FisherYatesShuffler struct{}

func (s FisherYatesShuffler) String() string {
	return "FisherYatesShuffler"
}

func (s FisherYatesShuffler) Shuffle(slice []int) []int {
	cp := make([]int, len(slice))
	copy(cp, slice)
	rand.Shuffle(len(cp), func(i, j int) { cp[i], cp[j] = cp[j], cp[i] })
	return cp
}
```

运行结果如下，可以看出这个算法是相当公平的：

```plain
------- shuffler: FisherYatesShuffler, n: 1, times: 100000 -------
normal possibility:
100%
actual relative possibility:
+0% 
------- shuffler: FisherYatesShuffler, n: 2, times: 100000 -------
normal possibility:
50%
actual relative possibility:
-0% +0% 
+0% -0% 
------- shuffler: FisherYatesShuffler, n: 3, times: 100000 -------
normal possibility:
33%
actual relative possibility:
-0% +0% +0% 
+0% -0% -0% 
+0% +0% -0% 
------- shuffler: FisherYatesShuffler, n: 4, times: 100000 -------
normal possibility:
25%
actual relative possibility:
+0% -0% -0% +0% 
+0% -0% -0% +0% 
-0% -0% +0% -0% 
-0% +0% -0% -0% 
------- shuffler: FisherYatesShuffler, n: 5, times: 100000 -------
normal possibility:
20%
actual relative possibility:
+0% -0% -0% +0% -0% 
+0% +0% +0% +0% -0% 
+0% -0% -0% -0% +0% 
-0% +0% -0% -0% -0% 
-0% -0% +0% +0% +0% 
------- shuffler: FisherYatesShuffler, n: 6, times: 100000 -------
normal possibility:
17%
actual relative possibility:
-0% +0% -0% +0% -0% -0% 
-0% +0% +0% +0% -0% +0% 
+0% -0% +0% -0% -0% +0% 
-0% -0% +0% +0% +0% -0% 
+0% -0% -0% +0% +0% -0% 
+0% +0% -0% -0% +0% +0% 
------- shuffler: FisherYatesShuffler, n: 7, times: 100000 -------
normal possibility:
14%
actual relative possibility:
-0% -0% +0% +0% +0% -0% -0% 
-0% +0% -0% +0% -0% -0% +0% 
+0% +0% -0% -0% -0% +0% +0% 
-0% -0% -0% +0% +0% +0% -0% 
+0% -0% +0% +0% -0% -0% -0% 
+0% -0% +0% -0% -0% -0% -0% 
-0% -0% -0% -0% +0% +0% +0% 
------- shuffler: FisherYatesShuffler, n: 8, times: 100000 -------
normal possibility:
12%
actual relative possibility:
+0% -0% +0% -0% +0% -0% +0% -0% 
-0% +0% -0% +0% +0% -0% -0% +0% 
+0% -0% +0% -0% +0% +0% -0% -0% 
+0% -0% -0% +0% -0% +0% +0% +0% 
+0% -0% -0% +0% +0% -0% +0% +0% 
-0% -0% +0% +0% -0% +0% -0% +0% 
-0% +0% +0% +0% -0% +0% +0% -0% 
+0% +0% -0% -0% +0% +0% -0% +0% 
------- shuffler: FisherYatesShuffler, n: 9, times: 100000 -------
normal possibility:
11%
actual relative possibility:
-0% -0% +0% -0% -0% +0% +0% -0% +0% 
-0% -0% +0% +0% -0% -0% +0% +0% +0% 
-0% +0% +0% -0% +0% +0% -0% +0% -0% 
-0% +0% +0% -0% +0% -0% -0% -0% +0% 
+0% -0% -0% +0% +0% -0% +0% -0% -0% 
-0% +0% +0% -0% -0% -0% -0% +0% +0% 
+0% -0% +0% -0% +0% -0% +0% +0% +0% 
+0% +0% -0% +0% -0% +0% -0% +0% +0% 
+0% -0% -0% +0% -0% +0% +0% -0% -0% 
------- shuffler: FisherYatesShuffler, n: 10, times: 100000 -------
normal possibility:
10%
actual relative possibility:
-0% -0% +0% +0% -0% +0% -0% -0% -0% +0% 
-0% +0% +0% +0% -0% -0% -0% -0% -0% +0% 
+0% +0% -0% -0% +0% -0% +0% -0% -0% -0% 
+0% +0% -0% +0% -0% +0% -0% +0% -0% -0% 
-0% -0% -0% +0% +0% +0% +0% -0% +0% -0% 
+0% -0% +0% -0% -0% +0% +0% +0% +0% -0% 
-0% +0% -0% -0% -0% -0% +0% +0% -0% +0% 
+0% -0% +0% -0% +0% -0% +0% -0% +0% +0% 
+0% -0% -0% +0% +0% +0% -0% -0% -0% +0% 
-0% -0% +0% -0% -0% +0% +0% +0% +0% -0% 
------- shuffler: FisherYatesShuffler, n: 11, times: 100000 -------
normal possibility:
9%
actual relative possibility:
-0% +0% -0% -0% -0% +0% -0% -0% +0% +0% +0% 
+0% +0% +0% +0% -0% +0% -0% -0% +0% -0% -0% 
+0% -0% -0% +0% -0% +0% -0% -0% +0% +0% -0% 
-0% +0% +0% +0% -0% -0% -0% -0% +0% +0% -0% 
-0% +0% +0% +0% +0% -0% -0% -0% -0% -0% +0% 
-0% -0% +0% +0% +0% -0% -0% -0% +0% -0% -0% 
+0% -0% +0% +0% +0% -0% +0% +0% -0% +0% -0% 
-0% -0% -0% -0% +0% -0% +0% +0% +0% +0% +0% 
+0% -0% +0% -0% -0% +0% -0% +0% -0% -0% +0% 
+0% -0% -0% -0% -0% +0% +0% +0% -0% -0% +0% 
+0% +0% -0% -0% +0% -0% -0% -0% -0% +0% +0% 
------- shuffler: FisherYatesShuffler, n: 12, times: 100000 -------
normal possibility:
8%
actual relative possibility:
-0% -0% +0% -0% +0% +0% -0% +0% -0% +0% +0% +0% 
-0% -0% -0% +0% -0% +0% +0% +0% -0% -0% -0% -0% 
+0% +0% -0% -0% +0% -0% -0% -0% +0% -0% +0% +0% 
+0% +0% -0% +0% +0% -0% +0% -0% +0% +0% -0% +0% 
-0% +0% -0% +0% +0% +0% -0% -0% -0% +0% +0% +0% 
-0% -0% +0% -0% -0% +0% +0% +0% +0% -0% +0% -0% 
-0% +0% +0% -0% +0% -0% +0% -0% -0% +0% +0% +0% 
+0% +0% +0% +0% -0% -0% -0% +0% +0% -0% +0% +0% 
-0% -0% -0% -0% -0% +0% +0% +0% +0% +0% +0% -0% 
-0% +0% +0% +0% -0% -0% +0% -0% +0% -0% -0% -0% 
-0% -0% +0% +0% -0% -0% +0% +0% +0% +0% -0% +0% 
+0% -0% -0% +0% -0% -0% +0% -0% -0% +0% +0% -0% 
------- shuffler: FisherYatesShuffler, n: 13, times: 100000 -------
normal possibility:
8%
actual relative possibility:
+0% -0% -0% -0% -0% +0% -0% -0% +0% -0% +0% +0% +0% 
+0% -0% +0% +0% -0% +0% +0% -0% -0% +0% -0% -0% +0% 
-0% +0% +0% -0% +0% +0% +0% +0% -0% -0% +0% -0% -0% 
+0% -0% +0% -0% -0% +0% +0% +0% -0% +0% -0% -0% -0% 
-0% +0% -0% +0% -0% +0% +0% -0% -0% -0% +0% -0% +0% 
-0% +0% +0% +0% +0% -0% -0% +0% +0% -0% -0% +0% -0% 
+0% -0% -0% -0% +0% -0% +0% -0% +0% +0% -0% +0% -0% 
+0% +0% -0% +0% +0% -0% +0% -0% -0% +0% -0% -0% -0% 
-0% +0% +0% -0% -0% -0% +0% +0% +0% -0% +0% +0% +0% 
-0% +0% -0% -0% +0% -0% -0% +0% +0% -0% +0% -0% +0% 
-0% +0% +0% +0% -0% -0% -0% +0% +0% +0% +0% +0% -0% 
+0% -0% -0% -0% -0% +0% -0% -0% +0% -0% -0% +0% +0% 
+0% -0% +0% -0% +0% -0% -0% -0% -0% +0% +0% -0% -0% 
------- shuffler: FisherYatesShuffler, n: 14, times: 100000 -------
normal possibility:
7%
actual relative possibility:
+0% +0% +0% -0% +0% +0% -0% +0% -0% -0% +0% -0% +0% -0% 
-0% +0% -0% -0% -0% -0% -0% +0% +0% +0% +0% +0% +0% +0% 
+0% -0% +0% -0% +0% +0% +0% -0% +0% +0% +0% +0% -0% +0% 
-0% +0% +0% +0% -0% +0% +0% +0% -0% +0% -0% -0% +0% -0% 
-0% +0% -0% +0% -0% +0% +0% -0% -0% +0% +0% -0% -0% -0% 
+0% -0% +0% +0% +0% -0% +0% -0% +0% -0% -0% -0% +0% -0% 
+0% +0% -0% +0% +0% +0% -0% -0% +0% -0% +0% -0% -0% -0% 
-0% +0% -0% +0% -0% -0% -0% +0% -0% +0% -0% +0% +0% -0% 
-0% -0% -0% +0% +0% -0% +0% -0% -0% -0% +0% +0% -0% +0% 
-0% -0% +0% -0% -0% +0% +0% +0% -0% +0% +0% +0% +0% -0% 
-0% +0% +0% -0% -0% -0% -0% +0% -0% -0% -0% +0% +0% +0% 
-0% -0% -0% +0% +0% -0% +0% +0% +0% -0% +0% +0% -0% -0% 
+0% -0% +0% -0% +0% +0% -0% +0% -0% +0% -0% +0% -0% +0% 
+0% -0% +0% -0% -0% +0% +0% -0% -0% -0% +0% +0% -0% +0% 
------- shuffler: FisherYatesShuffler, n: 15, times: 100000 -------
normal possibility:
7%
actual relative possibility:
+0% +0% +0% -0% -0% -0% -0% +0% -0% -0% -0% -0% +0% -0% +0% 
-0% +0% +0% -0% -0% -0% -0% -0% +0% +0% -0% +0% +0% -0% +0% 
+0% -0% -0% +0% +0% +0% +0% -0% -0% +0% +0% -0% -0% -0% +0% 
+0% +0% -0% -0% +0% -0% +0% -0% +0% -0% -0% +0% +0% +0% +0% 
-0% +0% -0% -0% -0% +0% +0% -0% +0% -0% +0% +0% +0% -0% +0% 
+0% -0% +0% +0% -0% +0% +0% -0% +0% -0% -0% -0% -0% +0% +0% 
+0% -0% -0% -0% -0% +0% +0% +0% -0% -0% +0% -0% -0% +0% +0% 
-0% +0% -0% +0% +0% -0% -0% +0% -0% -0% -0% -0% +0% -0% -0% 
+0% +0% -0% +0% +0% -0% -0% +0% -0% -0% +0% +0% -0% +0% -0% 
+0% +0% +0% -0% -0% +0% -0% -0% -0% -0% +0% +0% +0% +0% -0% 
-0% +0% +0% -0% -0% +0% +0% -0% +0% +0% -0% +0% +0% -0% -0% 
-0% -0% +0% -0% -0% +0% +0% +0% -0% +0% -0% +0% -0% -0% +0% 
+0% -0% +0% +0% -0% +0% -0% -0% -0% -0% +0% +0% -0% +0% -0% 
+0% -0% -0% +0% +0% +0% +0% -0% +0% +0% -0% -0% +0% +0% -0% 
+0% -0% -0% +0% +0% -0% +0% -0% +0% -0% +0% -0% +0% +0% -0% 
------- shuffler: FisherYatesShuffler, n: 16, times: 100000 -------
normal possibility:
6%
actual relative possibility:
+0% -0% +0% +0% +0% +0% -0% +0% -0% +0% -0% -0% -0% +0% -0% -0% 
-0% +0% -0% +0% -0% -0% +0% +0% +0% +0% +0% -0% -0% +0% +0% +0% 
+0% -0% -0% -0% +0% +0% +0% +0% -0% -0% +0% +0% +0% -0% +0% -0% 
-0% +0% -0% -0% +0% +0% -0% -0% +0% +0% -0% +0% -0% +0% +0% +0% 
-0% -0% +0% +0% +0% +0% -0% +0% +0% -0% -0% +0% +0% -0% -0% +0% 
+0% +0% -0% -0% -0% +0% +0% +0% -0% -0% +0% +0% +0% -0% -0% +0% 
-0% +0% +0% -0% -0% -0% +0% +0% +0% -0% +0% -0% +0% -0% +0% -0% 
-0% +0% +0% -0% +0% +0% -0% -0% -0% +0% -0% +0% +0% +0% -0% -0% 
+0% -0% +0% +0% +0% +0% -0% -0% -0% +0% +0% -0% +0% -0% +0% -0% 
+0% -0% -0% +0% +0% -0% -0% -0% -0% +0% +0% -0% +0% -0% -0% +0% 
-0% +0% -0% +0% -0% -0% +0% +0% -0% +0% -0% -0% +0% -0% -0% +0% 
-0% -0% +0% +0% +0% -0% +0% +0% +0% -0% +0% -0% -0% +0% +0% +0% 
+0% +0% -0% +0% -0% +0% +0% -0% +0% -0% -0% -0% -0% +0% -0% -0% 
-0% +0% -0% +0% -0% +0% -0% -0% +0% +0% +0% +0% -0% +0% +0% -0% 
+0% -0% +0% -0% +0% +0% +0% +0% -0% -0% -0% +0% -0% -0% +0% +0% 
+0% -0% +0% +0% -0% -0% -0% -0% +0% -0% +0% -0% +0% -0% -0% +0% 
------- shuffler: FisherYatesShuffler, n: 17, times: 100000 -------
normal possibility:
6%
actual relative possibility:
-0% +0% -0% -0% -0% -0% -0% +0% -0% +0% -0% +0% -0% +0% +0% +0% -0% 
+0% +0% -0% +0% +0% -0% +0% -0% -0% -0% +0% -0% +0% -0% -0% +0% +0% 
-0% +0% +0% -0% +0% -0% +0% +0% -0% +0% -0% -0% +0% +0% -0% -0% +0% 
-0% +0% -0% -0% -0% -0% +0% +0% +0% -0% +0% +0% -0% +0% +0% -0% -0% 
+0% -0% -0% -0% -0% -0% +0% +0% -0% +0% +0% -0% -0% +0% -0% -0% -0% 
+0% +0% +0% -0% -0% -0% -0% -0% +0% -0% -0% -0% +0% +0% -0% +0% -0% 
+0% -0% +0% -0% +0% -0% -0% -0% +0% +0% +0% +0% +0% +0% +0% -0% -0% 
+0% -0% +0% +0% +0% -0% +0% +0% -0% +0% +0% -0% -0% -0% -0% +0% -0% 
+0% +0% -0% -0% +0% +0% -0% +0% +0% -0% -0% -0% -0% -0% -0% +0% +0% 
-0% -0% +0% +0% -0% +0% +0% +0% -0% +0% -0% +0% +0% -0% +0% -0% -0% 
-0% -0% +0% +0% +0% +0% +0% +0% +0% -0% -0% +0% +0% -0% +0% -0% +0% 
-0% -0% -0% +0% +0% +0% -0% -0% +0% +0% +0% +0% -0% +0% +0% -0% +0% 
-0% +0% +0% +0% +0% -0% -0% +0% +0% -0% +0% -0% -0% -0% +0% -0% +0% 
-0% +0% -0% -0% -0% +0% -0% +0% +0% +0% -0% +0% +0% -0% -0% -0% +0% 
-0% +0% +0% +0% -0% +0% -0% +0% -0% -0% +0% -0% +0% +0% -0% +0% +0% 
+0% +0% -0% +0% -0% -0% -0% +0% -0% -0% -0% -0% +0% +0% +0% +0% -0% 
+0% -0% +0% -0% -0% +0% +0% -0% +0% +0% -0% +0% -0% -0% +0% -0% +0% 
------- shuffler: FisherYatesShuffler, n: 18, times: 100000 -------
normal possibility:
6%
actual relative possibility:
+0% +0% +0% -0% +0% +0% +0% -0% -0% -0% -0% +0% -0% -0% -0% -0% +0% -0% 
-0% -0% +0% -0% -0% -0% +0% +0% +0% -0% +0% -0% -0% +0% -0% -0% -0% +0% 
-0% -0% -0% +0% -0% -0% +0% -0% -0% -0% +0% +0% +0% +0% +0% +0% +0% -0% 
-0% +0% +0% +0% -0% +0% -0% +0% +0% +0% -0% +0% -0% -0% +0% +0% +0% -0% 
-0% -0% +0% +0% +0% +0% -0% -0% -0% +0% +0% -0% -0% +0% +0% +0% -0% -0% 
+0% +0% -0% -0% +0% +0% -0% -0% -0% +0% -0% +0% +0% +0% -0% -0% -0% +0% 
+0% +0% -0% -0% -0% +0% +0% -0% +0% +0% +0% -0% +0% -0% -0% +0% -0% -0% 
+0% +0% -0% +0% -0% -0% -0% +0% +0% +0% -0% -0% +0% +0% -0% -0% +0% +0% 
+0% +0% +0% -0% -0% -0% -0% +0% +0% -0% -0% -0% -0% -0% +0% +0% -0% -0% 
+0% -0% +0% +0% -0% +0% -0% +0% +0% -0% -0% +0% +0% +0% +0% -0% +0% +0% 
+0% +0% -0% -0% +0% -0% +0% +0% +0% -0% -0% -0% +0% +0% +0% +0% -0% +0% 
+0% -0% +0% +0% -0% +0% -0% +0% +0% -0% -0% +0% -0% -0% -0% +0% -0% +0% 
-0% +0% +0% -0% -0% -0% -0% +0% -0% -0% +0% +0% +0% +0% -0% -0% +0% +0% 
-0% -0% -0% -0% +0% -0% +0% -0% +0% +0% -0% +0% -0% -0% +0% -0% +0% +0% 
+0% +0% +0% +0% +0% +0% +0% -0% -0% -0% -0% -0% +0% -0% -0% +0% -0% -0% 
+0% -0% -0% +0% +0% -0% -0% +0% -0% +0% +0% +0% -0% -0% -0% -0% +0% -0% 
-0% -0% +0% +0% -0% +0% -0% -0% -0% -0% +0% +0% +0% +0% +0% -0% -0% +0% 
-0% +0% -0% +0% -0% +0% +0% -0% -0% +0% +0% -0% +0% +0% -0% +0% -0% -0% 
------- shuffler: FisherYatesShuffler, n: 19, times: 100000 -------
normal possibility:
5%
actual relative possibility:
+0% +0% -0% -0% -0% -0% +0% +0% -0% +0% -0% -0% +0% -0% -0% -0% -0% +0% +0% 
+0% +0% -0% -0% -0% +0% -0% +0% +0% -0% +0% -0% -0% -0% +0% +0% +0% +0% -0% 
-0% -0% -0% -0% -0% -0% -0% +0% +0% +0% +0% +0% +0% -0% -0% +0% +0% -0% -0% 
-0% +0% -0% -0% -0% -0% +0% -0% -0% -0% +0% -0% -0% +0% +0% +0% -0% +0% +0% 
-0% -0% +0% +0% -0% +0% -0% +0% +0% +0% +0% +0% -0% -0% +0% -0% +0% -0% -0% 
+0% +0% +0% -0% +0% -0% +0% +0% +0% -0% -0% -0% +0% -0% -0% +0% +0% -0% -0% 
-0% +0% +0% -0% -0% -0% -0% -0% +0% +0% -0% +0% +0% +0% +0% +0% +0% -0% -0% 
+0% +0% +0% -0% -0% -0% +0% +0% +0% -0% -0% +0% -0% -0% +0% -0% -0% +0% -0% 
+0% -0% -0% -0% +0% +0% +0% -0% +0% -0% -0% -0% -0% -0% -0% +0% -0% -0% +0% 
+0% -0% -0% -0% +0% +0% +0% +0% -0% +0% -0% +0% +0% +0% -0% -0% -0% +0% +0% 
-0% -0% +0% -0% +0% +0% -0% -0% +0% +0% -0% +0% +0% +0% +0% -0% -0% +0% +0% 
-0% +0% -0% +0% -0% +0% +0% -0% +0% +0% +0% -0% -0% +0% +0% +0% -0% -0% -0% 
+0% +0% +0% +0% -0% -0% +0% +0% -0% +0% +0% +0% +0% -0% -0% -0% +0% -0% +0% 
-0% -0% +0% +0% +0% +0% -0% +0% -0% -0% -0% +0% +0% +0% +0% -0% +0% +0% -0% 
-0% +0% +0% +0% -0% +0% -0% -0% -0% +0% -0% +0% -0% +0% +0% -0% -0% +0% +0% 
+0% -0% -0% +0% +0% -0% +0% -0% -0% +0% +0% +0% -0% -0% +0% -0% +0% +0% +0% 
+0% -0% +0% +0% -0% -0% -0% -0% +0% +0% -0% +0% +0% +0% +0% -0% -0% -0% -0% 
+0% +0% -0% -0% +0% -0% +0% -0% -0% -0% +0% +0% +0% -0% -0% +0% -0% -0% +0% 
+0% -0% +0% +0% -0% -0% +0% +0% -0% -0% +0% +0% -0% +0% -0% -0% +0% +0% -0% 
------- shuffler: FisherYatesShuffler, n: 20, times: 100000 -------
normal possibility:
5%
actual relative possibility:
-0% -0% -0% +0% -0% -0% +0% -0% -0% -0% +0% -0% -0% +0% +0% +0% +0% +0% -0% +0% 
+0% -0% -0% -0% -0% -0% +0% +0% -0% +0% +0% -0% +0% +0% -0% -0% +0% -0% +0% +0% 
+0% +0% +0% +0% -0% +0% +0% -0% +0% +0% -0% +0% +0% -0% -0% -0% -0% +0% +0% +0% 
+0% -0% +0% -0% +0% +0% -0% +0% -0% -0% -0% -0% -0% +0% +0% -0% +0% -0% -0% -0% 
+0% -0% -0% -0% +0% +0% +0% +0% +0% +0% -0% -0% +0% +0% -0% -0% -0% +0% +0% -0% 
-0% -0% -0% -0% -0% -0% +0% -0% +0% +0% +0% -0% +0% -0% +0% +0% -0% -0% +0% +0% 
-0% -0% -0% +0% -0% -0% -0% +0% -0% -0% +0% -0% +0% -0% +0% +0% +0% +0% -0% +0% 
+0% +0% +0% +0% +0% -0% -0% -0% -0% -0% +0% +0% +0% +0% -0% -0% -0% +0% -0% +0% 
-0% +0% -0% +0% -0% -0% +0% +0% +0% -0% -0% +0% -0% +0% -0% +0% +0% -0% +0% +0% 
-0% -0% +0% -0% -0% +0% -0% +0% +0% -0% +0% +0% +0% -0% +0% +0% -0% -0% +0% -0% 
-0% +0% +0% -0% -0% -0% +0% -0% -0% +0% +0% -0% -0% -0% -0% +0% +0% -0% -0% -0% 
+0% +0% -0% -0% +0% +0% +0% -0% +0% +0% -0% -0% +0% +0% -0% -0% +0% -0% +0% -0% 
-0% +0% -0% +0% +0% +0% +0% +0% -0% -0% -0% +0% -0% -0% -0% +0% -0% +0% -0% +0% 
-0% -0% +0% +0% +0% +0% -0% -0% +0% -0% -0% +0% -0% +0% +0% +0% -0% -0% +0% +0% 
-0% +0% +0% +0% -0% +0% -0% +0% +0% -0% +0% -0% +0% -0% -0% +0% +0% -0% -0% -0% 
-0% -0% +0% -0% -0% +0% +0% +0% +0% +0% -0% +0% -0% -0% +0% -0% -0% +0% +0% +0% 
+0% +0% -0% -0% -0% +0% -0% -0% +0% -0% +0% +0% -0% +0% -0% +0% +0% -0% +0% -0% 
-0% -0% +0% +0% -0% -0% -0% +0% -0% -0% +0% +0% -0% -0% -0% +0% +0% +0% -0% +0% 
+0% +0% -0% -0% +0% +0% +0% -0% +0% -0% -0% -0% +0% +0% -0% +0% +0% +0% +0% -0% 
+0% +0% +0% -0% +0% -0% +0% +0% -0% +0% +0% -0% -0% +0% +0% -0% -0% -0% -0% -0% 
```

下面我们分析一下该算法的数学推导，求原来在位置 `i` 的元素 `x` 按照 Fisher-Yates 洗牌后在位置 `j` 的概率 $P_{ij}$。根据算法规则，要达成目标，则必须在 `k=j` 的时候选中元素 `x` 并交换到位置 `k` 上，且之前的步骤中都不能选中元素 `x`：

1. 第一步时待选择的共有 `n` 个元素，不选中元素 `x` 的概率为 $\frac{n-1}{n}$
2. 第二步时待选择的共有 `n-1` 个元素，由于第一步没有选 `x` ，故 `x` 此时在这 `n-1` 个元素中，不选中元素 `x` 的概率为 $\frac{n-2}{n-1}$
3. 依次类推，直到第 `n-j` 步时，待选择的共有 `j+1` 个元素，选中元素 `x` 的概率为 $\frac{1}{j+1}$

所以，最终的概率 $P_{ij}$ 为

$$
\begin{equation}
P_{ij}=\frac{n-1}{n}\times\frac{n-2}{n-1}\times\frac{n-3}{n-2}\times\dots\times\frac{1}{j+1}=\frac{1}{n}
\end{equation}
$$


# 简单随机抽样算法

这一节我们正式讨论下简单随机抽样算法，即如何从 n 个元素的数组中等概率无重复随机抽取 m 个样本（m<n），这里我们额外要求不能改变原来数组

## 洗牌抽样

其实最开始我们就讨论了基于洗牌的抽样算法，但是我们错误地选取了基于排序的洗牌算法，这里我们只需要将其换掉，即采用 Fisher-Yates 算法洗牌后再取出前 `m` 个元素

由于 Fisher-Yates 算法本身是会改变原数组，所以上面的实现里我们先对原数组进行了拷贝，这里我们进行相同处理，所以其额外空间复杂度是 `O(n)`。另外，由于我们最终只会选取 `m` 个元素，故不用将洗牌过程进行完全，最终可以实现时间复杂度为 `O(m)` 的算法，算法代码和测试代码（在 `m=3` 的情况下）如下：

```go
func main() {
	sampler := FisherYatesSampler{}
	for i := 3; i <= 20; i++ {
		testSampling(sampler, generateSlice(i), 3, 1e5)
	}
}

type FisherYatesSampler struct{}

func (f FisherYatesSampler) String() string {
	return "FisherYatesSampler"
}

func (f FisherYatesSampler) Sampling(slice []int, m int) []int {
	cp := make([]int, len(slice))
	copy(cp, slice)
  
	n := len(cp)
	for i := n - 1; i >= n-m; i-- { // 这里i到达n-m位置就停止
		j := rand.Intn(i + 1)
		cp[i], cp[j] = cp[j], cp[i]
	}
	return cp[n-m:]
}
```

测试结果如下

```plain
------- sampler: FisherYatesSampler, n: 3, m:3, times: 100000 -------
normal possibility:
100%
actual relative possibility:
+0% +0% +0% 
------- sampler: FisherYatesSampler, n: 4, m:3, times: 100000 -------
normal possibility:
75%
actual relative possibility:
-0% +0% -0% -0% 
------- sampler: FisherYatesSampler, n: 5, m:3, times: 100000 -------
normal possibility:
60%
actual relative possibility:
+0% -0% +0% -0% +0% 
------- sampler: FisherYatesSampler, n: 6, m:3, times: 100000 -------
normal possibility:
50%
actual relative possibility:
-0% +0% +0% +0% -0% +0% 
------- sampler: FisherYatesSampler, n: 7, m:3, times: 100000 -------
normal possibility:
43%
actual relative possibility:
-0% -0% +0% +0% -0% +0% -0% 
------- sampler: FisherYatesSampler, n: 8, m:3, times: 100000 -------
normal possibility:
38%
actual relative possibility:
+0% +0% +0% -0% -0% +0% -0% -0% 
------- sampler: FisherYatesSampler, n: 9, m:3, times: 100000 -------
normal possibility:
33%
actual relative possibility:
+0% +0% -0% +0% -0% +0% -0% +0% -0% 
------- sampler: FisherYatesSampler, n: 10, m:3, times: 100000 -------
normal possibility:
30%
actual relative possibility:
+0% +0% -0% -0% -0% -0% +0% +0% -0% +0% 
------- sampler: FisherYatesSampler, n: 11, m:3, times: 100000 -------
normal possibility:
27%
actual relative possibility:
-0% -0% -0% -0% +0% +0% +0% +0% +0% -0% -0% 
------- sampler: FisherYatesSampler, n: 12, m:3, times: 100000 -------
normal possibility:
25%
actual relative possibility:
-0% -0% +0% +0% +0% +0% -0% -0% -0% -0% -0% -0% 
------- sampler: FisherYatesSampler, n: 13, m:3, times: 100000 -------
normal possibility:
23%
actual relative possibility:
-0% +0% -0% -0% +0% -0% +0% +0% +0% +0% +0% -0% +0% 
------- sampler: FisherYatesSampler, n: 14, m:3, times: 100000 -------
normal possibility:
21%
actual relative possibility:
+0% -0% -0% +0% +0% +0% -0% -0% +0% -0% -0% +0% +0% +0% 
------- sampler: FisherYatesSampler, n: 15, m:3, times: 100000 -------
normal possibility:
20%
actual relative possibility:
-0% +0% +0% +0% +0% -0% +0% -0% -0% +0% -0% -0% -0% -0% -0% 
------- sampler: FisherYatesSampler, n: 16, m:3, times: 100000 -------
normal possibility:
19%
actual relative possibility:
-0% +0% -0% -0% -0% +0% +0% +0% -0% -0% +0% +0% +0% -0% -0% -0% 
------- sampler: FisherYatesSampler, n: 17, m:3, times: 100000 -------
normal possibility:
18%
actual relative possibility:
-0% +0% -0% +0% +0% +0% -0% +0% -0% -0% +0% +0% -0% -0% +0% -0% +0% 
------- sampler: FisherYatesSampler, n: 18, m:3, times: 100000 -------
normal possibility:
17%
actual relative possibility:
+0% +0% +0% -0% +0% +0% +0% +0% +0% -0% +0% +0% -0% -0% +0% -0% -0% +0% 
------- sampler: FisherYatesSampler, n: 19, m:3, times: 100000 -------
normal possibility:
16%
actual relative possibility:
+0% -0% +0% -0% +0% -0% -0% -0% -0% +0% +0% -0% +0% -0% -0% +0% +0% +0% +0% 
------- sampler: FisherYatesSampler, n: 20, m:3, times: 100000 -------
normal possibility:
15%
actual relative possibility:
+0% +0% -0% -0% +0% +0% -0% -0% +0% -0% +0% -0% +0% -0% +0% +0% -0% +0% +0% -0% 
```

洗牌抽样的数学推导比较简单，上面已经推导了位置 `i` 上的元素在 Fisher-Yates 洗牌后出现在各个位置的概率均为 $\frac{1}{n}$，故只需要它出现在最终被选中的 `m` 个位置上即可
$$
P_i=\frac{1}{n}\times m= \frac{m}{n}
$$

## 有序抽样

洗牌抽样虽然是公平的，但是抽样出来的结果却不一定是原数组中的顺序，如果需要抽出的样本顺序和原数组的顺序相同，那么就只能重新再排序一下。当然，这样做就有点蠢了，有没有更好的算法呢？

容易想到，我们按序遍历数组中的元素，遍历时以一定的几率决定是否抽取该元素，这样抽样出来的结果就和原数组的顺序一致了。但这个几率如何确定有点难想到，这里先直接将算法过程概述如下：

1. 构造一个容量为 `m` 的结果数组 $a$，从 `i=0` 开始对总体数组进行遍历，设遍历到位置 `i` 之前已经选出了 `k ` 个元素
2. 对于第 `i` 个位置的元素，若 `k<=i`，则以 $\frac{m-k}{n-i}$ 的概率将其放入结果数组
3. 遍历完成或者结果数组长度到达 `m` 结束，结果数组中即为所有抽取的元素

测试代码如下，该算法额外空间复杂度为 `O(1)`：

```go
func main() {
	sampler := OrderedSampler{}
	for i := 3; i <= 20; i++ {
		testSampling(sampler, generateSlice(i), 3, 1e5)
	}
}

type OrderedSampler struct{}

func (s OrderedSampler) String() string {
	return "OrderedSampler"
}

func (s OrderedSampler) Sampling(slice []int, m int) []int {
	sampled := make([]int, 0, m)
	n := len(slice)
	for i := 0; i < n && len(sampled) < m; i++ {
		if s.roll(m-len(sampled), n-i) {
			sampled = append(sampled, slice[i])
		}
	}
	return sampled
}
```

测试结果如下

```plain
------- sampler: OrderedSampler, n: 3, m:3, times: 100000 -------
normal possibility:
100%
actual relative possibility:
+0% +0% +0% 
------- sampler: OrderedSampler, n: 4, m:3, times: 100000 -------
normal possibility:
75%
actual relative possibility:
+0% +0% -0% +0% 
------- sampler: OrderedSampler, n: 5, m:3, times: 100000 -------
normal possibility:
60%
actual relative possibility:
-0% +0% -0% +0% -0% 
------- sampler: OrderedSampler, n: 6, m:3, times: 100000 -------
normal possibility:
50%
actual relative possibility:
-0% -0% -0% +0% -0% +0% 
------- sampler: OrderedSampler, n: 7, m:3, times: 100000 -------
normal possibility:
43%
actual relative possibility:
+0% +0% -0% -0% -0% +0% +0% 
------- sampler: OrderedSampler, n: 8, m:3, times: 100000 -------
normal possibility:
38%
actual relative possibility:
-0% +0% -0% -0% -0% -0% -0% +0% 
------- sampler: OrderedSampler, n: 9, m:3, times: 100000 -------
normal possibility:
33%
actual relative possibility:
+0% +0% +0% +0% -0% +0% -0% -0% -0% 
------- sampler: OrderedSampler, n: 10, m:3, times: 100000 -------
normal possibility:
30%
actual relative possibility:
-0% +0% +0% +0% -0% +0% +0% -0% -0% +0% 
------- sampler: OrderedSampler, n: 11, m:3, times: 100000 -------
normal possibility:
27%
actual relative possibility:
+0% +0% -0% -0% +0% -0% +0% +0% -0% -0% -0% 
------- sampler: OrderedSampler, n: 12, m:3, times: 100000 -------
normal possibility:
25%
actual relative possibility:
+0% +0% +0% -0% -0% -0% -0% -0% +0% +0% +0% +0% 
------- sampler: OrderedSampler, n: 13, m:3, times: 100000 -------
normal possibility:
23%
actual relative possibility:
-0% -0% -0% +0% -0% +0% +0% -0% +0% -0% +0% -0% +0% 
------- sampler: OrderedSampler, n: 14, m:3, times: 100000 -------
normal possibility:
21%
actual relative possibility:
+0% +0% +0% +0% -0% +0% -0% -0% -0% -0% -0% -0% -0% +0% 
------- sampler: OrderedSampler, n: 15, m:3, times: 100000 -------
normal possibility:
20%
actual relative possibility:
+0% +0% -0% -0% -0% +0% -0% -0% +0% -0% -0% +0% -0% +0% +0% 
------- sampler: OrderedSampler, n: 16, m:3, times: 100000 -------
normal possibility:
19%
actual relative possibility:
-0% -0% +0% +0% +0% +0% +0% -0% -0% +0% -0% +0% +0% +0% -0% -0% 
------- sampler: OrderedSampler, n: 17, m:3, times: 100000 -------
normal possibility:
18%
actual relative possibility:
-0% +0% +0% +0% +0% -0% -0% -0% -0% +0% -0% +0% -0% +0% -0% +0% -0% 
------- sampler: OrderedSampler, n: 18, m:3, times: 100000 -------
normal possibility:
17%
actual relative possibility:
-0% -0% -0% +0% +0% -0% +0% -0% +0% +0% -0% +0% +0% -0% +0% -0% -0% +0% 
------- sampler: OrderedSampler, n: 19, m:3, times: 100000 -------
normal possibility:
16%
actual relative possibility:
+0% -0% +0% -0% +0% -0% -0% +0% +0% -0% +0% +0% -0% +0% +0% +0% +0% -0% -0% 
------- sampler: OrderedSampler, n: 20, m:3, times: 100000 -------
normal possibility:
15%
actual relative possibility:
+0% -0% +0% -0% +0% -0% -0% +0% +0% +0% +0% -0% -0% -0% -0% +0% +0% +0% +0% +0% 
```

该算法的时间复杂度在 `O(m)` 和 `O(n)` 之间：在「前 `m` 次循环每次都抽取成功」的情况下，得到最好时间复杂度 `O(m)`；在「最后一次循环结束后结果数组才满」的情况下，得到最坏时间复杂度 `O(n)`。如果需要计算这个算法的平均时间复杂度，则需要计算循环次数的期望值。易知，总共有 $C_n^m$ 种抽取情况，循环 `k` 次后恰好算法结束（第 `k` 次循环成功抽取并放入后，结果数组恰好装满）的情况有 $C_{k-1}^{m-1}$ 种，故其平均时间复杂度为 $O(\sum_{k=m}^n k \,C_{k-1}^{m-1}  / C_n^m)$

这个算法的数学证明目前我没完全想明白，设 $P_i$ 为 `i` 位置最终在结果数组的概率，则按照算法逻辑和贝叶斯公式，我们需要证明
$$
\begin{equation}
P_i = \sum_{所有情况} P(之前已抽取k个元素)\cdot P(取出i位置元素|之前已抽取k个元素) \equiv \frac{m}{n}
\end{equation}
$$
其中 $P(抽取i位置元素|之前已抽取k个元素)$ 这个条件概率算法已经给出，其值为 $\frac{m-k}{n-i}$

我们先用数学归纳法推一下：首先 `i=0` 时，易知 $P_0=\frac{m}{n}$ 成立，其次我们假设 `i-1` 之前均成立，则 $P_0=P_1=\cdots =P_{i-1}=\frac{m}{n}$，则有
$$
\begin{equation}
P(之前已抽取k个元素)=C_{i}^{k}(\frac{n}{m})^k(1-\frac{m}{n})^{i-k}
\end{equation}
$$
带入原式则有
$$
\begin{equation}
P_i=\sum_{k=0}^i[C_{i}^{k}(\frac{n}{m})^k(1-\frac{m}{n})^{i-k}(\frac{m-k}{n-i})]=\frac{m}{n}
\end{equation}
$$
故在 `i` 时也成立，故原式得证

> 最后一步的证明详见[附录](#附录)

##  蓄水池算法

前两个算法都需要在事前知道总体数量 `n` 的确切数值，或者甚至需要事前将所有的总体元素装入内存，这一节介绍一个简单随机抽样方面比较著名的算法，即[蓄水池算法](https://en.wikipedia.org/wiki/Reservoir_sampling)

我们先简单看一下这个算法：

1. 构造一个容量为 `m` 的结果数组 $a$，从 `i=0` 开始遍历总体数组
2. 当 `i<m ` 时，直接将当前元素放入结果数组
3. 当 `i>=m` 时，以 $\frac{m}{i+1}$ 的概率抽取该元素，若成功抽取则使用该元素随机替换结果数组中的某一元素
4. 遍历完后结束，结果数组中即为抽取的元素

测试代码如下，该算法额外空间复杂度为 `O(1)`，时间复杂度为 `O(n)`：

```go
func main() {
	sampler := ReservoirSampler{}
	for i := 3; i <= 20; i++ {
		testSampling(sampler, generateSlice(i), 3, 1e5)
	}
}

type ReservoirSampler struct{}

func (r ReservoirSampler) String() string {
	return "ReservoirSampler"
}

func (r ReservoirSampler) Sampling(slice []int, m int) []int {
	sampled := make([]int, 0, m)
	for i, num := range slice {
		if i < m {
			sampled = append(sampled, num)
			continue
		}
    // 这里只使用了一个随机数，同时完成了m/i+1概率抽取和随机替换逻辑
		if k := rand.Intn(i + 1); k < m { 
			sampled[k] = num
		}
	}
	return sampled
}
```

测试结果如下

```plain
------- sampler: ReservoirSampler, n: 3, m:3, times: 100000 -------
normal possibility:
100%
actual relative possibility:
+0% +0% +0% 
------- sampler: ReservoirSampler, n: 4, m:3, times: 100000 -------
normal possibility:
75%
actual relative possibility:
-0% +0% -0% +0% 
------- sampler: ReservoirSampler, n: 5, m:3, times: 100000 -------
normal possibility:
60%
actual relative possibility:
-0% -0% +0% +0% +0% 
------- sampler: ReservoirSampler, n: 6, m:3, times: 100000 -------
normal possibility:
50%
actual relative possibility:
-0% -0% +0% +0% +0% -0% 
------- sampler: ReservoirSampler, n: 7, m:3, times: 100000 -------
normal possibility:
43%
actual relative possibility:
-0% +0% +0% +0% +0% -0% -0% 
------- sampler: ReservoirSampler, n: 8, m:3, times: 100000 -------
normal possibility:
38%
actual relative possibility:
-0% -0% +0% -0% +0% +0% +0% -0% 
------- sampler: ReservoirSampler, n: 9, m:3, times: 100000 -------
normal possibility:
33%
actual relative possibility:
-0% +0% +0% +0% +0% -0% -0% -0% -0% 
------- sampler: ReservoirSampler, n: 10, m:3, times: 100000 -------
normal possibility:
30%
actual relative possibility:
+0% +0% -0% -0% +0% -0% +0% +0% -0% -0% 
------- sampler: ReservoirSampler, n: 11, m:3, times: 100000 -------
normal possibility:
27%
actual relative possibility:
+0% +0% +0% -0% -0% +0% -0% +0% +0% -0% -0% 
------- sampler: ReservoirSampler, n: 12, m:3, times: 100000 -------
normal possibility:
25%
actual relative possibility:
+0% +0% -0% -0% -0% -0% +0% +0% -0% -0% +0% +0% 
------- sampler: ReservoirSampler, n: 13, m:3, times: 100000 -------
normal possibility:
23%
actual relative possibility:
-0% +0% -0% -0% +0% -0% +0% +0% -0% +0% +0% -0% -0% 
------- sampler: ReservoirSampler, n: 14, m:3, times: 100000 -------
normal possibility:
21%
actual relative possibility:
+0% -0% -0% +0% +0% +0% -0% -0% +0% -0% -0% +0% +0% -0% 
------- sampler: ReservoirSampler, n: 15, m:3, times: 100000 -------
normal possibility:
20%
actual relative possibility:
-0% +0% +0% -0% -0% -0% -0% +0% -0% -0% -0% +0% +0% +0% +0% 
------- sampler: ReservoirSampler, n: 16, m:3, times: 100000 -------
normal possibility:
19%
actual relative possibility:
-0% +0% -0% -0% -0% +0% +0% +0% -0% +0% +0% -0% +0% -0% -0% -0% 
------- sampler: ReservoirSampler, n: 17, m:3, times: 100000 -------
normal possibility:
18%
actual relative possibility:
+0% +0% -0% +0% -0% -0% -0% +0% +0% -0% -0% +0% -0% +0% -0% +0% -0% 
------- sampler: ReservoirSampler, n: 18, m:3, times: 100000 -------
normal possibility:
17%
actual relative possibility:
-0% -0% -0% +0% +0% -0% +0% +0% +0% +0% -0% -0% +0% +0% +0% -0% -0% -0% 
------- sampler: ReservoirSampler, n: 19, m:3, times: 100000 -------
normal possibility:
16%
actual relative possibility:
+0% +0% +0% +0% -0% +0% +0% +0% +0% +0% -0% -0% +0% -0% -0% +0% -0% +0% -0% 
------- sampler: ReservoirSampler, n: 20, m:3, times: 100000 -------
normal possibility:
15%
actual relative possibility:
+0% -0% -0% -0% -0% -0% +0% +0% -0% +0% -0% +0% +0% +0% +0% -0% -0% +0% +0% -0% 
```

下面我们分析一下该算法的数学推导，求遍历到 `i` 位置时，任一遍历过的元素（设其原位置为 `j(j<=i)` ）出现在结果数组中的概率 $P_{ij}$

首先，我们在遍历到 `m` 下标之前时，遍历过的元素都被会被放入结果数组，故有：
$$
\begin{equation}
P_{ij} \equiv 1, i < m
\end{equation}
$$
接下来我们分两种情况来考虑，我们关注元素的原位置 `j` 可能在 `m` 之前，也可能在 `m` 之后：

若是前一种情况，则遍历到 `m` 位置时，这个元素肯定已经在结果数组中，我们只需要保证后面的过程中它不被顶替出来即可（易知遍历到 `k` 位置时该元素将结果集中的某元素顶替出来的概率是 $\frac{m}{k+1}\times\frac{1}{m} = \frac{k}{k+1}$）
$$
\begin{equation}
P_{ij}=\prod_{k=m}^{i}(1-\frac{k}{k+1})=\prod_{k=m}^{i}\frac{k}{k+1}=\frac{m}{i+1}, i\ge m,j<m
\end{equation}
$$
若是后一种情况，则我们需要在遍历到该元素时将其选中并放入结果数组，另需要保证后面过程中它不被顶替出来
$$
\begin{equation}
P_{ij}=\frac{m}{j+1}\times\prod_{k=j+1}^{i}\frac{k}{k+1}=\frac{m}{i+1},i\ge m,j\ge m
\end{equation}
$$
综合可得
$$
\begin{equation}
P_{ij}=P_{i}=\begin{cases}
   1  &  i<m \\
   \frac{m}{i+1} &  i\ge m
 \end{cases}
\end{equation}
$$
$P_{ij}$ 和 $j$ 无关，即已经遍历的元素被选入结果数组是等概率的，而且对于遍历中的每一步均成立，当遍历到数组末尾（ `i=n-1` 时），数组中的每个元素被选入结果数组的概率都是 $P_n=\frac{m}{n}$。从这里我们可以推出这个算法的天秀之处：能够实现**“流式”**的抽样，即只需遍历一遍元素，且过程中不用知道总体数 `n` 的具体值，且能保证在遍历的过程中，每一步的抽样结果是等概率随机的。故蓄水池算法天生地适合于下面三种场景：

* 总体数量很大，不能全部读入内存
* 事先不知道总体数量
* 可以允许查看中间过程的抽样结果

# 总结

本文主要讨论了简单随机抽样问题，即从 n 个元素的数组中等概率无重复随机抽取 m 个样本（m<n），不能改变原来数组

首先从一份不公平的抽奖代码出发，分析出了其「不公平」的原因：该抽奖算法先洗牌后抽样，但却使用了基于排序的洗牌算法，而基于排序的洗牌算法并非随机。其次，本文介绍了三种比较经典的抽样算法，分别是洗牌抽样、有序抽样和蓄水池算法，这三种算法各有特点，相互比较如下：

| 简单随机抽样算法 | 时间复杂度  | 额外空间复杂度 | 特点               |
| ---------------- | ----------- | -------------- | ------------------ |
| 洗牌抽样         | O(m)        | O(n)           | 快速               |
| 有序抽样         | O(m) ~ O(n) | O(1)           | 有序，不占额外空间 |
| 蓄水池算法       | O(n)        | O(1)           | 流式，不占额外空间 |

# 参考资料

* [前端进阶数组乱序](https://juejin.cn/post/6844903863812620296)

# 附录

关于 $\sum_{k=0}^i[C_{i}^{k}(\frac{n}{m})^k(1-\frac{m}{n})^{i-k}(\frac{m-k}{n-i})]=\frac{m}{n}$ 的证明，感谢 @予一人 在[知乎](https://www.zhihu.com/question/454424405)上的解答，现摘抄如下：

设 $p=\frac{m}{n}, q=1-\frac{m}{n}$，由二项式定理有
$$
\begin{equation}
(px+q)^i=\sum_{k=0}^iC_i^kp^kq^{i-k}x^k
\end{equation}
$$
两端同时对 $x$ 求导，并同乘 $x$ 有
$$
\begin{equation}
ipx(px+q)^{i-1}=\sum_{k=0}^iC_i^kkp^kq^{i-k}x^k
\end{equation}
$$
令 $x=1$ 代入上述两式，并注意到 $p+q=1$，可得
$$
\begin{align}
1=&\sum_{k=0}^iC_i^kp^kq^{i-k}\\
ip=&\sum_{k=0}^iC_i^kkp^kq^{i-k}
\end{align}
$$
故原式可化简为
$$
\begin{align}
\nonumber &\sum_{k=0}^i[C_{i}^{k}(\frac{n}{m})^k(1-\frac{m}{n})^{i-k}(\frac{m-k}{n-i})]\\
=&\frac{m}{n-i}\sum_{k=0}^iC_{i}^{k}(\frac{n}{m})^k(1-\frac{m}{n})^{i-k}-\frac{1}{n-i}\sum_{k=0}^iC_{i}^{k}k(\frac{n}{m})^k(1-\frac{m}{n})^{i-k}\\
= &\frac{m}{n-i}\sum_{k=0}^iC_{i}^{k}p^kq^{i-k}-\frac{1}{n-i}\sum_{k=0}^iC_{i}^{k}kp^kq^{i-k}\\
=&\frac{m}{n-i}\cdot1-\frac{1}{n-i}\cdot ip =\frac{m}{n}
\end{align}
$$
